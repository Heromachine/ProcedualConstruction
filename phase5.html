<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Wave Function Collapse — Phase 5</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    background: #0a141e;
    color: #c8d8e8;
    font-family: 'Segoe UI', system-ui, sans-serif;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 14px;
    padding: 24px;
  }
  #menu-link { position:fixed; top:14px; left:16px; color:#7ab4d4; text-decoration:none; font-size:13px; opacity:0.75; transition:opacity 0.15s; }
  #menu-link:hover { opacity:1; }
  h1 { font-size:20px; font-weight:600; letter-spacing:0.03em; color:#ddeeff; }
  .subtitle { font-size:12px; color:#6a8fa8; letter-spacing:0.04em; }
  canvas { border-radius:4px; box-shadow:0 4px 32px rgba(0,0,0,0.7), 0 0 0 1px rgba(255,255,255,0.06); display:block; }
  .controls { display:flex; align-items:center; gap:10px; flex-wrap:wrap; justify-content:center; }
  button { background:#1a2d3f; color:#a8c8e0; border:1px solid rgba(255,255,255,0.1); border-radius:5px; padding:6px 16px; font-size:13px; cursor:pointer; transition:background 0.15s, color 0.15s; }
  button:hover { background:#253d54; color:#ddeeff; }
  .hint { font-size:11px; color:#4a6a80; }
  .legend { display:flex; gap:14px; flex-wrap:wrap; justify-content:center; font-size:11px; color:#7a9ab0; }
  .legend-item { display:flex; align-items:center; gap:5px; }
  .legend-dot { width:10px; height:10px; border-radius:50%; flex-shrink:0; }
  #wfc-status {
    font-size: 11px;
    color: #5a8aaa;
    letter-spacing: 0.04em;
    min-width: 260px;
    text-align: center;
  }
</style>
</head>
<body>
<a href="index.html" id="menu-link">&#8592; Menu</a>
<h1>Wave Function Collapse &#8212; Phase 5</h1>
<p class="subtitle">Autonomous island generation &middot; WFC algorithm &middot; Bad North technique</p>
<canvas id="c"></canvas>
<div class="controls">
  <button id="btn-gen">Generate</button>
  <button id="btn-step">Step</button>
  <button id="btn-pause">Pause</button>
  <button id="btn-speed">Speed 5&times;</button>
</div>
<span id="wfc-status">Press Generate to start</span>
<div class="legend">
  <div class="legend-item"><div class="legend-dot" style="background:#1a4d72"></div>water</div>
  <div class="legend-item"><div class="legend-dot" style="background:#2d7a4f"></div>forest</div>
  <div class="legend-item"><div class="legend-dot" style="background:#5a9040"></div>meadow</div>
  <div class="legend-item"><div class="legend-dot" style="background:#1f5e40"></div>deep</div>
  <div class="legend-item"><div class="legend-dot" style="background:#6a7a30"></div>scrub</div>
  <div class="legend-item"><div class="legend-dot" style="background:#5a9060"></div>mountain</div>
  <div class="legend-item"><div class="legend-dot" style="background:#4a8858"></div>ridge</div>
</div>
<script>
const CELL=52, COLS=14, ROWS=14, JITTER=CELL*0.38;
const C = { bgDeep:'#0d1e2d', water:'#1a4d72', dotOff:'rgba(80,160,220,0.35)', dotOn:'rgba(255,210,80,0.95)', grid:'rgba(255,255,255,0.05)' };
const VARIANTS = [
  { land:'#2d7a4f', edge:'#3d9960', dot:'rgba(130,220,100,0.22)' },
  { land:'#5a9040', edge:'#72b050', dot:'rgba(190,240,90,0.28)'  },
  { land:'#1f5e40', edge:'#286850', dot:'rgba(80,190,130,0.20)'  },
  { land:'#6a7a30', edge:'#828f40', dot:'rgba(210,210,70,0.24)'  },
];
const canvas=document.getElementById('c'), ctx=canvas.getContext('2d');
canvas.width=COLS*CELL; canvas.height=ROWS*CELL;
let points=[], grid=[], cellData=[];

// WFC state
let wfcWeights = [];
let wfcCollapsed = [];
let wfcDone = false;
let wfcAnimId = null;
let wfcSpeed = 5;
let wfcPaused = false;

function initState() {
  grid=Array.from({length:ROWS+1},()=>Array(COLS+1).fill(false));
  cellData=Array.from({length:ROWS},()=>Array.from({length:COLS},()=>({v:0,seed:Math.random()*0xffffffff>>>0})));
}

function seededRng(seed) {
  let s=(seed^0xdeadbeef)>>>0||1;
  return ()=>{ s^=s<<13; s^=s>>17; s^=s<<5; return (s>>>0)/0xFFFFFFFF; };
}

function generateOrganic() {
  const pts=Array.from({length:ROWS+1},(_,r)=>Array.from({length:COLS+1},(_,c)=>{
    const onBorder=r===0||r===ROWS||c===0||c===COLS;
    return { x:c*CELL+(onBorder?0:(Math.random()-0.5)*JITTER*2), y:r*CELL+(onBorder?0:(Math.random()-0.5)*JITTER*2) };
  }));
  for(let iter=0;iter<5;iter++) for(let r=1;r<ROWS;r++) for(let c=1;c<COLS;c++)
    pts[r][c]={ x:(pts[r-1][c].x+pts[r+1][c].x+pts[r][c-1].x+pts[r][c+1].x)/4, y:(pts[r-1][c].y+pts[r+1][c].y+pts[r][c-1].y+pts[r][c+1].y)/4 };
  return pts;
}

function midpt(a,b){ return {x:(a.x+b.x)/2,y:(a.y+b.y)/2}; }

function getCellType(col,row){
  let t=0;
  if(grid[row][col]) t|=8; if(grid[row][col+1]) t|=4;
  if(grid[row+1][col+1]) t|=2; if(grid[row+1][col]) t|=1;
  return t;
}

function buildQuadPath(ctx,type,p0,p1,p2,p3){
  const m01=midpt(p0,p1),m12=midpt(p1,p2),m23=midpt(p2,p3),m30=midpt(p3,p0);
  switch(type){
    case 0: break;
    case 15: ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.lineTo(p3.x,p3.y); ctx.closePath(); break;
    case 8:  ctx.moveTo(m01.x,m01.y); ctx.quadraticCurveTo(p0.x,p0.y,m30.x,m30.y); ctx.closePath(); break;
    case 4:  ctx.moveTo(m12.x,m12.y); ctx.quadraticCurveTo(p1.x,p1.y,m01.x,m01.y); ctx.closePath(); break;
    case 2:  ctx.moveTo(m23.x,m23.y); ctx.quadraticCurveTo(p2.x,p2.y,m12.x,m12.y); ctx.closePath(); break;
    case 1:  ctx.moveTo(m30.x,m30.y); ctx.quadraticCurveTo(p3.x,p3.y,m23.x,m23.y); ctx.closePath(); break;
    case 12: ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.lineTo(m12.x,m12.y); ctx.quadraticCurveTo(m23.x,m23.y,m30.x,m30.y); ctx.closePath(); break;
    case 6:  ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.lineTo(m23.x,m23.y); ctx.quadraticCurveTo(m30.x,m30.y,m01.x,m01.y); ctx.closePath(); break;
    case 3:  ctx.moveTo(p2.x,p2.y); ctx.lineTo(p3.x,p3.y); ctx.lineTo(m30.x,m30.y); ctx.quadraticCurveTo(m01.x,m01.y,m12.x,m12.y); ctx.closePath(); break;
    case 9:  ctx.moveTo(p3.x,p3.y); ctx.lineTo(p0.x,p0.y); ctx.lineTo(m01.x,m01.y); ctx.quadraticCurveTo(m12.x,m12.y,m23.x,m23.y); ctx.closePath(); break;
    case 10: ctx.moveTo(m01.x,m01.y); ctx.quadraticCurveTo(p0.x,p0.y,m30.x,m30.y); ctx.closePath(); ctx.moveTo(m23.x,m23.y); ctx.quadraticCurveTo(p2.x,p2.y,m12.x,m12.y); ctx.closePath(); break;
    case 5:  ctx.moveTo(m12.x,m12.y); ctx.quadraticCurveTo(p1.x,p1.y,m01.x,m01.y); ctx.closePath(); ctx.moveTo(m30.x,m30.y); ctx.quadraticCurveTo(p3.x,p3.y,m23.x,m23.y); ctx.closePath(); break;
    case 14: ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.lineTo(m23.x,m23.y); ctx.quadraticCurveTo(p3.x,p3.y,m30.x,m30.y); ctx.closePath(); break;
    case 13: ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.lineTo(m12.x,m12.y); ctx.quadraticCurveTo(p2.x,p2.y,m23.x,m23.y); ctx.lineTo(p3.x,p3.y); ctx.closePath(); break;
    case 11: ctx.moveTo(p0.x,p0.y); ctx.lineTo(m01.x,m01.y); ctx.quadraticCurveTo(p1.x,p1.y,m12.x,m12.y); ctx.lineTo(p2.x,p2.y); ctx.lineTo(p3.x,p3.y); ctx.closePath(); break;
    case 7:  ctx.moveTo(m30.x,m30.y); ctx.quadraticCurveTo(p0.x,p0.y,m01.x,m01.y); ctx.lineTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.lineTo(p3.x,p3.y); ctx.closePath(); break;
  }
}

function updateCellData(pgCol,pgRow){
  const neighbors=[[pgRow-1,pgCol-1],[pgRow-1,pgCol],[pgRow,pgCol-1],[pgRow,pgCol]];
  for(const [cr,cc] of neighbors)
    if(cr>=0&&cr<ROWS&&cc>=0&&cc<COLS)
      cellData[cr][cc]={v:Math.floor(Math.random()*VARIANTS.length),seed:Math.random()*0xffffffff>>>0};
}

function nearestPoint(mx,my){
  let best=null,bestDist=Infinity;
  for(let r=0;r<=ROWS;r++) for(let c=0;c<=COLS;c++){
    const pt=points[r][c],dx=pt.x-mx,dy=pt.y-my,d=dx*dx+dy*dy;
    if(d<bestDist){bestDist=d;best={r,c};}
  }
  return best;
}

function findSpecialPieces() {
  const claimed = Array.from({length:ROWS}, ()=>Array(COLS).fill(false));
  const pieces = [];
  // 2x2 mountain first (highest priority)
  for (let r=0; r<=ROWS-2; r++) for (let c=0; c<=COLS-2; c++) {
    if (claimed[r][c]||claimed[r][c+1]||claimed[r+1][c]||claimed[r+1][c+1]) continue;
    if ([getCellType(c,r),getCellType(c+1,r),getCellType(c,r+1),getCellType(c+1,r+1)].every(t=>t===15)) {
      pieces.push({kind:'mountain',dc:c,dr:r});
      claimed[r][c]=claimed[r][c+1]=claimed[r+1][c]=claimed[r+1][c+1]=true;
    }
  }
  // 1x3 horizontal ridge
  for (let r=0; r<ROWS; r++) for (let c=0; c<=COLS-3; c++) {
    if (claimed[r][c]||claimed[r][c+1]||claimed[r][c+2]) continue;
    if ([getCellType(c,r),getCellType(c+1,r),getCellType(c+2,r)].every(t=>t===15)) {
      pieces.push({kind:'ridgeH',dc:c,dr:r});
      claimed[r][c]=claimed[r][c+1]=claimed[r][c+2]=true;
    }
  }
  // 3x1 vertical ridge
  for (let r=0; r<=ROWS-3; r++) for (let c=0; c<COLS; c++) {
    if (claimed[r][c]||claimed[r+1][c]||claimed[r+2][c]) continue;
    if ([getCellType(c,r),getCellType(c,r+1),getCellType(c,r+2)].every(t=>t===15)) {
      pieces.push({kind:'ridgeV',dc:c,dr:r});
      claimed[r][c]=claimed[r+1][c]=claimed[r+2][c]=true;
    }
  }
  return {pieces, claimed};
}

function drawSpecialPiece(piece) {
  ctx.save();
  if (piece.kind === 'mountain') {
    const dc = piece.dc, dr = piece.dr;
    const cx = points[dr+1][dc+1].x;
    const cy = points[dr+1][dc+1].y;
    const width = ((points[dr][dc+2].x - points[dr][dc].x) + (points[dr+2][dc+2].x - points[dr+2][dc].x)) / 2;
    const height = ((points[dr+2][dc].y - points[dr][dc].y) + (points[dr+2][dc+2].y - points[dr][dc+2].y)) / 2;
    const rx = width * 0.44;
    const ry = height * 0.40;

    ctx.beginPath();
    ctx.ellipse(cx, cy + ry*0.25, rx*1.05, ry*0.3, 0, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(10,25,15,0.5)';
    ctx.fill();

    const grad = ctx.createRadialGradient(cx - rx*0.2, cy - ry*0.35, 0, cx, cy, Math.max(rx, ry));
    grad.addColorStop(0,   '#7ab870');
    grad.addColorStop(0.45,'#3a7850');
    grad.addColorStop(1,   '#1a4030');
    ctx.beginPath();
    ctx.ellipse(cx, cy - ry*0.05, rx, ry, 0, 0, Math.PI*2);
    ctx.fillStyle = grad;
    ctx.fill();

    ctx.beginPath();
    ctx.ellipse(cx, cy - ry*0.05, rx, ry, 0, 0, Math.PI*2);
    ctx.strokeStyle = '#2a6040';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    ctx.beginPath();
    ctx.ellipse(cx - rx*0.18, cy - ry*0.38, rx*0.35, ry*0.22, 0, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(200,255,180,0.18)';
    ctx.fill();

  } else if (piece.kind === 'ridgeH') {
    const dc = piece.dc, dr = piece.dr;
    const cx = (points[dr][dc].x + points[dr][dc+3].x + points[dr+1][dc].x + points[dr+1][dc+3].x) / 4;
    const cy = (points[dr][dc].y + points[dr][dc+3].y + points[dr+1][dc].y + points[dr+1][dc+3].y) / 4;
    const width = (points[dr][dc+3].x - points[dr][dc].x + points[dr+1][dc+3].x - points[dr+1][dc].x) / 2;
    const height = (points[dr+1][dc].y - points[dr][dc].y + points[dr+1][dc+3].y - points[dr][dc+3].y) / 2;
    const rx = width * 0.46;
    const ry = height * 0.34;

    ctx.beginPath();
    ctx.ellipse(cx, cy + ry*0.22, rx*1.02, ry*0.28, 0, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(10,25,15,0.4)';
    ctx.fill();

    const grad = ctx.createRadialGradient(cx, cy - ry*0.3, 0, cx, cy, Math.max(rx, ry));
    grad.addColorStop(0,   '#90c878');
    grad.addColorStop(0.5, '#4a8858');
    grad.addColorStop(1,   '#1e5038');
    ctx.beginPath();
    ctx.ellipse(cx, cy - ry*0.04, rx, ry, 0, 0, Math.PI*2);
    ctx.fillStyle = grad;
    ctx.fill();

    ctx.beginPath();
    ctx.ellipse(cx, cy - ry*0.04, rx, ry, 0, 0, Math.PI*2);
    ctx.strokeStyle = '#346848';
    ctx.lineWidth = 1.2;
    ctx.stroke();

    ctx.beginPath();
    ctx.ellipse(cx - rx*0.1, cy - ry*0.3, rx*0.5, ry*0.2, 0, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(200,255,180,0.15)';
    ctx.fill();

  } else if (piece.kind === 'ridgeV') {
    const dc = piece.dc, dr = piece.dr;
    const cx = (points[dr][dc].x + points[dr][dc+1].x + points[dr+3][dc].x + points[dr+3][dc+1].x) / 4;
    const cy = (points[dr][dc].y + points[dr][dc+1].y + points[dr+3][dc].y + points[dr+3][dc+1].y) / 4;
    const width = (points[dr][dc+1].x - points[dr][dc].x + points[dr+3][dc+1].x - points[dr+3][dc].x) / 2;
    const height = (points[dr+3][dc].y - points[dr][dc].y + points[dr+3][dc+1].y - points[dr][dc+1].y) / 2;
    const rx = width * 0.34;
    const ry = height * 0.46;

    ctx.beginPath();
    ctx.ellipse(cx, cy + ry*0.22, rx*1.02, ry*0.28, 0, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(10,25,15,0.4)';
    ctx.fill();

    const grad = ctx.createRadialGradient(cx, cy - ry*0.3, 0, cx, cy, Math.max(rx, ry));
    grad.addColorStop(0,   '#90c878');
    grad.addColorStop(0.5, '#4a8858');
    grad.addColorStop(1,   '#1e5038');
    ctx.beginPath();
    ctx.ellipse(cx, cy - ry*0.04, rx, ry, 0, 0, Math.PI*2);
    ctx.fillStyle = grad;
    ctx.fill();

    ctx.beginPath();
    ctx.ellipse(cx, cy - ry*0.04, rx, ry, 0, 0, Math.PI*2);
    ctx.strokeStyle = '#346848';
    ctx.lineWidth = 1.2;
    ctx.stroke();

    ctx.beginPath();
    ctx.ellipse(cx - rx*0.1, cy - ry*0.3, rx*0.5, ry*0.2, 0, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(200,255,180,0.15)';
    ctx.fill();
  }
  ctx.restore();
}

function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle=C.bgDeep; ctx.fillRect(0,0,canvas.width,canvas.height);

  const {pieces, claimed} = findSpecialPieces();

  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
    const p0=points[r][c],p1=points[r][c+1],p2=points[r+1][c+1],p3=points[r+1][c];
    const type=getCellType(c,r),cd=cellData[r][c],vr=VARIANTS[cd.v];
    ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.lineTo(p3.x,p3.y); ctx.closePath();
    ctx.fillStyle=C.water; ctx.fill();
    if(type===0||claimed[r][c]) continue;
    ctx.beginPath(); buildQuadPath(ctx,type,p0,p1,p2,p3); ctx.fillStyle=vr.land; ctx.fill();
    ctx.save(); ctx.beginPath(); buildQuadPath(ctx,type,p0,p1,p2,p3); ctx.clip();
    const rng=seededRng(cd.seed);
    const minX=Math.min(p0.x,p1.x,p2.x,p3.x),maxX=Math.max(p0.x,p1.x,p2.x,p3.x);
    const minY=Math.min(p0.y,p1.y,p2.y,p3.y),maxY=Math.max(p0.y,p1.y,p2.y,p3.y);
    ctx.fillStyle=vr.dot;
    for(let i=0;i<14;i++){ ctx.beginPath(); ctx.arc(minX+rng()*(maxX-minX),minY+rng()*(maxY-minY),1.5+rng()*3,0,Math.PI*2); ctx.fill(); }
    ctx.restore();
    ctx.beginPath(); buildQuadPath(ctx,type,p0,p1,p2,p3); ctx.strokeStyle=vr.edge; ctx.lineWidth=1.2; ctx.stroke();
  }

  for(const piece of pieces) drawSpecialPiece(piece);

  ctx.strokeStyle=C.grid; ctx.lineWidth=1;
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
    const p0=points[r][c],p1=points[r][c+1],p2=points[r+1][c+1],p3=points[r+1][c];
    ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.lineTo(p3.x,p3.y); ctx.closePath(); ctx.stroke();
  }
  for(let r=0;r<=ROWS;r++) for(let c=0;c<=COLS;c++){
    const pt=points[r][c],on=grid[r][c];
    ctx.beginPath(); ctx.arc(pt.x,pt.y,on?4:2.5,0,Math.PI*2); ctx.fillStyle=on?C.dotOn:C.dotOff; ctx.fill();
  }
}

// ---- WFC Functions ----

function initWFC() {
  wfcDone = false;
  wfcPaused = false;
  if (wfcAnimId) { cancelAnimationFrame(wfcAnimId); wfcAnimId = null; }

  // Reset grid to all water
  grid = Array.from({length:ROWS+1}, () => Array(COLS+1).fill(false));
  cellData = Array.from({length:ROWS}, () =>
    Array.from({length:COLS}, () => ({v: Math.floor(Math.random()*VARIANTS.length), seed: Math.random()*0xffffffff>>>0}))
  );

  // Init weights
  wfcWeights = Array.from({length:ROWS+1}, () => Array(COLS+1).fill(0.5));
  wfcCollapsed = Array.from({length:ROWS+1}, () => Array(COLS+1).fill(false));

  // Pin all border points to water (collapsed)
  for (let c = 0; c <= COLS; c++) {
    wfcCollapsed[0][c] = wfcCollapsed[ROWS][c] = true;
    wfcWeights[0][c] = wfcWeights[ROWS][c] = 0;
  }
  for (let r = 0; r <= ROWS; r++) {
    wfcCollapsed[r][0] = wfcCollapsed[r][COLS] = true;
    wfcWeights[r][0] = wfcWeights[r][COLS] = 0;
  }

  // Apply center-bias to interior uncollapsed points
  const centerR = ROWS / 2, centerC = COLS / 2;
  const maxDist = Math.sqrt(centerR * centerR + centerC * centerC);
  for (let r = 1; r < ROWS; r++) for (let c = 1; c < COLS; c++) {
    const d = Math.sqrt((r - centerR) ** 2 + (c - centerC) ** 2);
    wfcWeights[r][c] = Math.max(0.12, 0.82 - (d / maxDist) * 0.72);
  }

  // Seed the center point to LAND to anchor the island
  const sr = Math.round(ROWS / 2), sc = Math.round(COLS / 2);
  wfcCollapsed[sr][sc] = true;
  grid[sr][sc] = true;
  updateCellData(sc, sr);
  propagateWFC(sr, sc, true);
}

function propagateWFC(r, c, value) {
  // Cardinal neighbors: strong influence
  const cardinals = [[r-1,c],[r+1,c],[r,c-1],[r,c+1]];
  for (const [nr, nc] of cardinals) {
    if (nr < 0 || nr > ROWS || nc < 0 || nc > COLS) continue;
    if (wfcCollapsed[nr][nc]) continue;
    if (value) {
      wfcWeights[nr][nc] = Math.min(0.91, wfcWeights[nr][nc] + 0.24 * (1 - wfcWeights[nr][nc]));
    } else {
      wfcWeights[nr][nc] = Math.max(0.09, wfcWeights[nr][nc] * 0.76);
    }
  }
  // Diagonal neighbors: weaker influence
  const diags = [[r-1,c-1],[r-1,c+1],[r+1,c-1],[r+1,c+1]];
  for (const [nr, nc] of diags) {
    if (nr < 0 || nr > ROWS || nc < 0 || nc > COLS) continue;
    if (wfcCollapsed[nr][nc]) continue;
    if (value) {
      wfcWeights[nr][nc] = Math.min(0.88, wfcWeights[nr][nc] + 0.12 * (1 - wfcWeights[nr][nc]));
    } else {
      wfcWeights[nr][nc] = Math.max(0.12, wfcWeights[nr][nc] * 0.88);
    }
  }
}

function collapseOne() {
  // Find uncollapsed interior point with most extreme weight (minimum entropy)
  let best = null, bestScore = -1;
  for (let r = 1; r < ROWS; r++) for (let c = 1; c < COLS; c++) {
    if (wfcCollapsed[r][c]) continue;
    const w = wfcWeights[r][c];
    const score = Math.abs(w - 0.5) + Math.random() * 0.015;
    if (score > bestScore) { bestScore = score; best = {r, c}; }
  }
  if (!best) { wfcDone = true; return; }

  const {r, c} = best;
  const w = wfcWeights[r][c];
  const value = Math.random() < w;

  grid[r][c] = value;
  wfcCollapsed[r][c] = true;
  updateCellData(c, r);
  propagateWFC(r, c, value);

  // Check if done
  let remaining = 0;
  for (let rr = 1; rr < ROWS; rr++) for (let cc = 1; cc < COLS; cc++)
    if (!wfcCollapsed[rr][cc]) remaining++;
  if (remaining === 0) wfcDone = true;
  updateStatus(remaining);
}

function updateStatus(remaining) {
  const el = document.getElementById('wfc-status');
  if (!el) return;
  if (wfcDone) {
    const {pieces} = findSpecialPieces();
    const mountains = pieces.filter(p => p.kind==='mountain').length;
    const ridges = pieces.filter(p => p.kind!=='mountain').length;
    el.textContent = `Complete · ${mountains} mountain${mountains!==1?'s':''} · ${ridges} ridge${ridges!==1?'s':''}`;
  } else {
    el.textContent = `Collapsing… ${remaining} points remaining`;
  }
}

function renderWFC() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle=C.bgDeep; ctx.fillRect(0,0,canvas.width,canvas.height);

  // Pass 1: water bg for all cells, then land for collapsed cells
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
    const p0=points[r][c],p1=points[r][c+1],p2=points[r+1][c+1],p3=points[r+1][c];

    // Water bg always
    ctx.beginPath();
    ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.lineTo(p3.x,p3.y);
    ctx.closePath();
    ctx.fillStyle=C.water; ctx.fill();

    // Determine if ALL 4 corners of this cell are collapsed
    const allCollapsed = wfcCollapsed[r][c] && wfcCollapsed[r][c+1] && wfcCollapsed[r+1][c+1] && wfcCollapsed[r+1][c];

    if (allCollapsed) {
      // Full land tile rendering for collapsed cells
      const type=getCellType(c,r);
      if (type !== 0) {
        const cd=cellData[r][c], vr=VARIANTS[cd.v];
        ctx.beginPath(); buildQuadPath(ctx,type,p0,p1,p2,p3); ctx.fillStyle=vr.land; ctx.fill();
        // dots
        ctx.save(); ctx.beginPath(); buildQuadPath(ctx,type,p0,p1,p2,p3); ctx.clip();
        const rng=seededRng(cd.seed);
        const minX=Math.min(p0.x,p1.x,p2.x,p3.x),maxX=Math.max(p0.x,p1.x,p2.x,p3.x);
        const minY=Math.min(p0.y,p1.y,p2.y,p3.y),maxY=Math.max(p0.y,p1.y,p2.y,p3.y);
        ctx.fillStyle=vr.dot;
        for(let i=0;i<14;i++){ ctx.beginPath(); ctx.arc(minX+rng()*(maxX-minX),minY+rng()*(maxY-minY),1.5+rng()*3,0,Math.PI*2); ctx.fill(); }
        ctx.restore();
        ctx.beginPath(); buildQuadPath(ctx,type,p0,p1,p2,p3); ctx.strokeStyle=vr.edge; ctx.lineWidth=1.2; ctx.stroke();
      }
    } else {
      // Ghost quad: tinted by weight of the cell's average weight
      // Use the average weight of the 4 corners for this cell's tint
      const w00 = wfcWeights[r][c];
      const w01 = wfcWeights[r][c+1];
      const w10 = wfcWeights[r+1][c];
      const w11 = wfcWeights[r+1][c+1];
      // Use uncollapsed corners only for average, fallback to all
      let wSum = 0, wCount = 0;
      if (!wfcCollapsed[r][c])     { wSum += w00; wCount++; }
      if (!wfcCollapsed[r][c+1])   { wSum += w01; wCount++; }
      if (!wfcCollapsed[r+1][c])   { wSum += w10; wCount++; }
      if (!wfcCollapsed[r+1][c+1]) { wSum += w11; wCount++; }
      const avgW = wCount > 0 ? wSum / wCount : (w00+w01+w10+w11)/4;

      let ghostColor;
      if (avgW > 0.5) {
        const alpha = (avgW - 0.5) * 2 * 0.35;
        ghostColor = `rgba(80,180,120,${alpha.toFixed(3)})`;
      } else {
        const alpha = (0.5 - avgW) * 2 * 0.20;
        ghostColor = `rgba(40,80,180,${alpha.toFixed(3)})`;
      }

      ctx.beginPath();
      ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.lineTo(p3.x,p3.y);
      ctx.closePath();
      ctx.fillStyle = ghostColor;
      ctx.fill();
    }
  }

  // No special pieces during collapse

  // Grid overlay
  ctx.strokeStyle=C.grid; ctx.lineWidth=1;
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
    const p0=points[r][c],p1=points[r][c+1],p2=points[r+1][c+1],p3=points[r+1][c];
    ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.lineTo(p3.x,p3.y); ctx.closePath(); ctx.stroke();
  }

  // Points: collapsed land=dotOn (r=4), collapsed water=dotOff (r=2.5), uncollapsed=purple pulse (r=2)
  for(let r=0;r<=ROWS;r++) for(let c=0;c<=COLS;c++){
    const pt=points[r][c];
    if (wfcCollapsed[r][c]) {
      const on = grid[r][c];
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, on ? 4 : 2.5, 0, Math.PI*2);
      ctx.fillStyle = on ? C.dotOn : C.dotOff;
      ctx.fill();
    } else {
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, 2, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(140,100,200,0.6)';
      ctx.fill();
    }
  }
}

function tick() {
  if (wfcPaused || wfcDone) return;
  for (let i = 0; i < wfcSpeed; i++) {
    if (wfcDone) break;
    collapseOne();
  }
  renderWFC();
  if (!wfcDone) {
    wfcAnimId = requestAnimationFrame(tick);
  } else {
    render();
  }
}

function startWFC() {
  if (wfcAnimId) cancelAnimationFrame(wfcAnimId);
  wfcAnimId = requestAnimationFrame(tick);
}

// ---- Button handlers ----

document.getElementById('btn-gen').addEventListener('click', () => {
  if (wfcAnimId) cancelAnimationFrame(wfcAnimId);
  wfcAnimId = null;
  // Reset pause button label
  document.getElementById('btn-pause').textContent = 'Pause';
  initState();
  points = generateOrganic();
  initWFC();
  renderWFC();
  startWFC();
});

document.getElementById('btn-step').addEventListener('click', () => {
  if (!wfcDone) {
    collapseOne();
    if (wfcDone) render(); else renderWFC();
  }
});

document.getElementById('btn-pause').addEventListener('click', () => {
  if (wfcDone) return;
  wfcPaused = !wfcPaused;
  document.getElementById('btn-pause').textContent = wfcPaused ? 'Resume' : 'Pause';
  if (!wfcPaused) startWFC();
});

document.getElementById('btn-speed').addEventListener('click', () => {
  const speeds = [1, 5, 20];
  const labels = ['1\u00d7', '5\u00d7', '20\u00d7'];
  const idx = speeds.indexOf(wfcSpeed);
  const next = (idx + 1) % speeds.length;
  wfcSpeed = speeds[next];
  document.getElementById('btn-speed').textContent = 'Speed ' + labels[next];
});

// ---- Init ----
initState();
points = generateOrganic();
initWFC();
renderWFC();
startWFC();
</script>
</body>
</html>
