<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Phase 3 — Organic Grid</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    background: #0a141e;
    color: #c8d8e8;
    font-family: 'Segoe UI', system-ui, sans-serif;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 14px;
    padding: 24px;
  }
  #menu-link {
    position: fixed;
    top: 14px;
    left: 16px;
    color: #7ab4d4;
    text-decoration: none;
    font-size: 13px;
    opacity: 0.75;
    transition: opacity 0.15s;
  }
  #menu-link:hover { opacity: 1; }
  h1 { font-size: 20px; font-weight: 600; letter-spacing: 0.03em; color: #ddeeff; }
  .subtitle { font-size: 12px; color: #6a8fa8; letter-spacing: 0.04em; }
  canvas {
    cursor: crosshair;
    border-radius: 4px;
    box-shadow: 0 4px 32px rgba(0,0,0,0.7), 0 0 0 1px rgba(255,255,255,0.06);
    display: block;
  }
  .controls {
    display: flex;
    align-items: center;
    gap: 10px;
    flex-wrap: wrap;
    justify-content: center;
  }
  button {
    background: #1a2d3f;
    color: #a8c8e0;
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 5px;
    padding: 6px 16px;
    font-size: 13px;
    cursor: pointer;
    transition: background 0.15s, color 0.15s;
  }
  button:hover { background: #253d54; color: #ddeeff; }
  .hint { font-size: 11px; color: #4a6a80; }
  .legend {
    display: flex;
    gap: 14px;
    flex-wrap: wrap;
    justify-content: center;
    font-size: 11px;
    color: #7a9ab0;
  }
  .legend-item { display: flex; align-items: center; gap: 5px; }
  .legend-dot {
    width: 10px; height: 10px;
    border-radius: 50%;
    flex-shrink: 0;
  }
</style>
</head>
<body>
<a href="index.html" id="menu-link">&#8592; Menu</a>
<h1>Organic Grid &mdash; Phase 3</h1>
<p class="subtitle">Jittered grid &middot; Laplacian relaxation &middot; Quad-based rendering</p>
<canvas id="c"></canvas>
<div class="controls">
  <button id="btn-gen">Generate</button>
  <button id="btn-clear">Clear</button>
  <button id="btn-rand">Randomize</button>
  <span class="hint">Click or drag to paint land</span>
</div>
<div class="legend">
  <div class="legend-item"><div class="legend-dot" style="background:#1a4d72"></div>water</div>
  <div class="legend-item"><div class="legend-dot" style="background:#2d7a4f"></div>forest</div>
  <div class="legend-item"><div class="legend-dot" style="background:#5a9040"></div>meadow</div>
  <div class="legend-item"><div class="legend-dot" style="background:#1f5e40"></div>deep</div>
  <div class="legend-item"><div class="legend-dot" style="background:#6a7a30"></div>scrub</div>
</div>

<script>
const CELL = 52;
const COLS = 14;
const ROWS = 14;
const JITTER = CELL * 0.38;

const C = {
  bgDeep: '#0d1e2d',
  water:  '#1a4d72',
  dotOff: 'rgba(80,160,220,0.35)',
  dotOn:  'rgba(255,210,80,0.95)',
  grid:   'rgba(255,255,255,0.05)',
};

const VARIANTS = [
  { land: '#2d7a4f', edge: '#3d9960', dot: 'rgba(130,220,100,0.22)' },
  { land: '#5a9040', edge: '#72b050', dot: 'rgba(190,240,90,0.28)'  },
  { land: '#1f5e40', edge: '#286850', dot: 'rgba(80,190,130,0.20)'  },
  { land: '#6a7a30', edge: '#828f40', dot: 'rgba(210,210,70,0.24)'  },
];

const canvas = document.getElementById('c');
const ctx    = canvas.getContext('2d');
canvas.width  = COLS * CELL;
canvas.height = ROWS * CELL;

// State
let points   = [];  // points[r][c] = {x,y}
let grid     = [];  // grid[r][c] = bool (land)
let cellData = [];  // cellData[r][c] = {v, seed}

function initState() {
  grid = Array.from({length: ROWS+1}, () => Array(COLS+1).fill(false));
  cellData = Array.from({length: ROWS}, () =>
    Array.from({length: COLS}, () => ({ v: 0, seed: Math.random() * 0xffffffff >>> 0 }))
  );
}

function seededRng(seed) {
  let s = (seed ^ 0xdeadbeef) >>> 0 || 1;
  return () => {
    s ^= s << 13; s ^= s >> 17; s ^= s << 5;
    return (s >>> 0) / 0xFFFFFFFF;
  };
}

function generateOrganic() {
  const pts = Array.from({length: ROWS+1}, (_, r) =>
    Array.from({length: COLS+1}, (_, c) => {
      const onBorder = r===0 || r===ROWS || c===0 || c===COLS;
      return {
        x: c * CELL + (onBorder ? 0 : (Math.random()-0.5) * JITTER * 2),
        y: r * CELL + (onBorder ? 0 : (Math.random()-0.5) * JITTER * 2)
      };
    })
  );
  for (let iter = 0; iter < 5; iter++) {
    for (let r = 1; r < ROWS; r++) {
      for (let c = 1; c < COLS; c++) {
        pts[r][c] = {
          x: (pts[r-1][c].x + pts[r+1][c].x + pts[r][c-1].x + pts[r][c+1].x) / 4,
          y: (pts[r-1][c].y + pts[r+1][c].y + pts[r][c-1].y + pts[r][c+1].y) / 4
        };
      }
    }
  }
  return pts;
}

function midpt(a, b) {
  return { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
}

function getCellType(col, row) {
  let t = 0;
  if (grid[row][col])     t |= 8; // TL
  if (grid[row][col+1])   t |= 4; // TR
  if (grid[row+1][col+1]) t |= 2; // BR
  if (grid[row+1][col])   t |= 1; // BL
  return t;
}

// Builds quad path onto current ctx path (caller does beginPath)
function buildQuadPath(ctx, type, p0, p1, p2, p3) {
  const m01 = midpt(p0, p1);
  const m12 = midpt(p1, p2);
  const m23 = midpt(p2, p3);
  const m30 = midpt(p3, p0);

  switch (type) {
    case 0: break;
    case 15:
      ctx.moveTo(p0.x, p0.y);
      ctx.lineTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.lineTo(p3.x, p3.y);
      ctx.closePath();
      break;
    case 8: // TL only
      ctx.moveTo(m01.x, m01.y);
      ctx.quadraticCurveTo(p0.x, p0.y, m30.x, m30.y);
      ctx.closePath();
      break;
    case 4: // TR only
      ctx.moveTo(m12.x, m12.y);
      ctx.quadraticCurveTo(p1.x, p1.y, m01.x, m01.y);
      ctx.closePath();
      break;
    case 2: // BR only
      ctx.moveTo(m23.x, m23.y);
      ctx.quadraticCurveTo(p2.x, p2.y, m12.x, m12.y);
      ctx.closePath();
      break;
    case 1: // BL only
      ctx.moveTo(m30.x, m30.y);
      ctx.quadraticCurveTo(p3.x, p3.y, m23.x, m23.y);
      ctx.closePath();
      break;
    case 12: // TL+TR
      ctx.moveTo(p0.x, p0.y);
      ctx.lineTo(p1.x, p1.y);
      ctx.lineTo(m12.x, m12.y);
      ctx.quadraticCurveTo(m23.x, m23.y, m30.x, m30.y);
      ctx.closePath();
      break;
    case 6: // TR+BR
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.lineTo(m23.x, m23.y);
      ctx.quadraticCurveTo(m30.x, m30.y, m01.x, m01.y);
      ctx.closePath();
      break;
    case 3: // BR+BL
      ctx.moveTo(p2.x, p2.y);
      ctx.lineTo(p3.x, p3.y);
      ctx.lineTo(m30.x, m30.y);
      ctx.quadraticCurveTo(m01.x, m01.y, m12.x, m12.y);
      ctx.closePath();
      break;
    case 9: // BL+TL
      ctx.moveTo(p3.x, p3.y);
      ctx.lineTo(p0.x, p0.y);
      ctx.lineTo(m01.x, m01.y);
      ctx.quadraticCurveTo(m12.x, m12.y, m23.x, m23.y);
      ctx.closePath();
      break;
    case 10: // TL+BR diagonal
      ctx.moveTo(m01.x, m01.y);
      ctx.quadraticCurveTo(p0.x, p0.y, m30.x, m30.y);
      ctx.closePath();
      ctx.moveTo(m23.x, m23.y);
      ctx.quadraticCurveTo(p2.x, p2.y, m12.x, m12.y);
      ctx.closePath();
      break;
    case 5: // TR+BL diagonal
      ctx.moveTo(m12.x, m12.y);
      ctx.quadraticCurveTo(p1.x, p1.y, m01.x, m01.y);
      ctx.closePath();
      ctx.moveTo(m30.x, m30.y);
      ctx.quadraticCurveTo(p3.x, p3.y, m23.x, m23.y);
      ctx.closePath();
      break;
    case 14: // miss BL
      ctx.moveTo(p0.x, p0.y);
      ctx.lineTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.lineTo(m23.x, m23.y);
      ctx.quadraticCurveTo(p3.x, p3.y, m30.x, m30.y);
      ctx.closePath();
      break;
    case 13: // miss BR
      ctx.moveTo(p0.x, p0.y);
      ctx.lineTo(p1.x, p1.y);
      ctx.lineTo(m12.x, m12.y);
      ctx.quadraticCurveTo(p2.x, p2.y, m23.x, m23.y);
      ctx.lineTo(p3.x, p3.y);
      ctx.closePath();
      break;
    case 11: // miss TR
      ctx.moveTo(p0.x, p0.y);
      ctx.lineTo(m01.x, m01.y);
      ctx.quadraticCurveTo(p1.x, p1.y, m12.x, m12.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.lineTo(p3.x, p3.y);
      ctx.closePath();
      break;
    case 7: // miss TL
      ctx.moveTo(m30.x, m30.y);
      ctx.quadraticCurveTo(p0.x, p0.y, m01.x, m01.y);
      ctx.lineTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.lineTo(p3.x, p3.y);
      ctx.closePath();
      break;
  }
}

function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = C.bgDeep;
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const p0 = points[r][c];
      const p1 = points[r][c+1];
      const p2 = points[r+1][c+1];
      const p3 = points[r+1][c];
      const type = getCellType(c, r);
      const cd   = cellData[r][c];
      const vr   = VARIANTS[cd.v];

      // Water background (always fill quad)
      ctx.beginPath();
      ctx.moveTo(p0.x, p0.y);
      ctx.lineTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.lineTo(p3.x, p3.y);
      ctx.closePath();
      ctx.fillStyle = C.water;
      ctx.fill();

      if (type === 0) continue;

      // Land fill
      ctx.beginPath();
      buildQuadPath(ctx, type, p0, p1, p2, p3);
      ctx.fillStyle = vr.land;
      ctx.fill();

      // Detail dots clipped to land shape
      ctx.save();
      ctx.beginPath();
      buildQuadPath(ctx, type, p0, p1, p2, p3);
      ctx.clip();

      const rng = seededRng(cd.seed);
      const minX = Math.min(p0.x, p1.x, p2.x, p3.x);
      const maxX = Math.max(p0.x, p1.x, p2.x, p3.x);
      const minY = Math.min(p0.y, p1.y, p2.y, p3.y);
      const maxY = Math.max(p0.y, p1.y, p2.y, p3.y);
      const dotCount = 14;
      ctx.fillStyle = vr.dot;
      for (let i = 0; i < dotCount; i++) {
        const dx = minX + rng() * (maxX - minX);
        const dy = minY + rng() * (maxY - minY);
        const dr = 1.5 + rng() * 3;
        ctx.beginPath();
        ctx.arc(dx, dy, dr, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();

      // Edge highlight
      ctx.beginPath();
      buildQuadPath(ctx, type, p0, p1, p2, p3);
      ctx.strokeStyle = vr.edge;
      ctx.lineWidth = 1.2;
      ctx.stroke();
    }
  }

  // Grid overlay — quad outlines
  ctx.strokeStyle = C.grid;
  ctx.lineWidth = 1;
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const p0 = points[r][c];
      const p1 = points[r][c+1];
      const p2 = points[r+1][c+1];
      const p3 = points[r+1][c];
      ctx.beginPath();
      ctx.moveTo(p0.x, p0.y);
      ctx.lineTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.lineTo(p3.x, p3.y);
      ctx.closePath();
      ctx.stroke();
    }
  }

  // Grid point dots
  for (let r = 0; r <= ROWS; r++) {
    for (let c = 0; c <= COLS; c++) {
      const pt = points[r][c];
      const on = grid[r][c];
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, on ? 4 : 2.5, 0, Math.PI * 2);
      ctx.fillStyle = on ? C.dotOn : C.dotOff;
      ctx.fill();
    }
  }
}

function nearestPoint(mx, my) {
  let best = null;
  let bestDist = Infinity;
  for (let r = 0; r <= ROWS; r++) {
    for (let c = 0; c <= COLS; c++) {
      const pt = points[r][c];
      const dx = pt.x - mx;
      const dy = pt.y - my;
      const d = dx*dx + dy*dy;
      if (d < bestDist) {
        bestDist = d;
        best = { r, c };
      }
    }
  }
  return best;
}

function updateCellData(pgCol, pgRow) {
  // pgCol, pgRow = grid point column/row index
  // Surrounding cells: TL cell=(pgRow-1,pgCol-1), TR=(pgRow-1,pgCol), BL=(pgRow,pgCol-1), BR=(pgRow,pgCol)
  const neighbors = [
    [pgRow-1, pgCol-1],
    [pgRow-1, pgCol],
    [pgRow,   pgCol-1],
    [pgRow,   pgCol],
  ];
  for (const [cr, cc] of neighbors) {
    if (cr >= 0 && cr < ROWS && cc >= 0 && cc < COLS) {
      cellData[cr][cc] = {
        v:    Math.floor(Math.random() * VARIANTS.length),
        seed: Math.random() * 0xffffffff >>> 0,
      };
    }
  }
}

// Interaction
let painting = false;
let paintValue = true;

canvas.addEventListener('mousedown', e => {
  painting = true;
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const my = (e.clientY - rect.top)  * (canvas.height / rect.height);
  const pt = nearestPoint(mx, my);
  if (pt) {
    paintValue = !grid[pt.r][pt.c];
    grid[pt.r][pt.c] = paintValue;
    updateCellData(pt.c, pt.r);
    render();
  }
});

canvas.addEventListener('mousemove', e => {
  if (!painting) return;
  const rect = canvas.getBoundingClientRect();
  const mx = (e.clientX - rect.left) * (canvas.width / rect.width);
  const my = (e.clientY - rect.top)  * (canvas.height / rect.height);
  const pt = nearestPoint(mx, my);
  if (pt && grid[pt.r][pt.c] !== paintValue) {
    grid[pt.r][pt.c] = paintValue;
    updateCellData(pt.c, pt.r);
    render();
  }
});

window.addEventListener('mouseup', () => { painting = false; });

// Buttons
document.getElementById('btn-gen').addEventListener('click', () => {
  initState();
  points = generateOrganic();
  render();
});

document.getElementById('btn-clear').addEventListener('click', () => {
  grid = Array.from({length: ROWS+1}, () => Array(COLS+1).fill(false));
  render();
});

document.getElementById('btn-rand').addEventListener('click', () => {
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      cellData[r][c] = {
        v:    Math.floor(Math.random() * VARIANTS.length),
        seed: Math.random() * 0xffffffff >>> 0,
      };
    }
  }
  render();
});

// Init
initState();
points = generateOrganic();
render();
</script>
</body>
</html>
